import json
import numpy as np

class Model():
    def __init__(self, setting, extrusion_symbol="U"):
        self.setting = setting
        self.code = []
        self.header = ['; +-+-+- RepRap gcode generated by pathway. ']
        self.footer = ['; [EOF]']
        self.options = [extrusion_symbol, 
                        setting['retractionLiftZ'], 
                        setting['startExtraLength'], 
                        setting['startCompression'], 
                        setting['startCompressionTime']]
    def set_header(self, header):
        for element in header:
            self.header.append(element)
        pass
    def set_footer(self, footer):
        for element in footer:
            self.footer.append(element)
        pass
    def stack(self, layer, z):
        self.code.append('G00 Z{:.2f}\n'.format(z))
        self.code.extend(layer.gcodeGen(z, *self.options))
    def generate(self, fname='untitled.gcode'):
        f = open(fname, 'w')
        f.writelines(self.header)
        f.writelines(self.code)
        f.writelines(self.footer)
        f.close
        pass

class gPath():
    def __init__(self, path):
        self.path = path
        pass
    def coords(self):
        x, y = [], []
        for i in range(len(self.path)):
            x.append(self.path[i].start.real)
            y.append(self.path[i].start.imag)
        x.append(self.path[-1].end.real)
        y.append(self.path[-1].end.imag)
        return (x, y)
    def lengths(self):    
        l = []
        for line in self.path:
            l.append(line.length())
        return l
    
class Layer():
    def __init__(self, gpaths, extrusion_map, feedrate_map):
        self.paths = gpaths
        self.map = extrusion_map
        self.feed = feedrate_map
    
    def cuttingConfig(self, command, mergin):
        self.cutmergin = mergin
        self.cutCommand = command

    def gcodeGen(self, z, extrusion_symbol='U', retractionLiftZ=0.0, startExtraLength=0.0, startCompression=0.0, startCompressionTime=0.0):
        code = []
        for i in range(len(self.paths)):
            flag = 2
            x = self.paths[i].coords()[0]
            y = self.paths[i].coords()[1]
            l = self.paths[i].lengths()

            if i == int(len(self.paths)-1):
                x1 = self.paths[i].coords()[0]
                y1 = self.paths[i].coords()[1]
            else:
                x1 = self.paths[i+1].coords()[0]
                y1 = self.paths[i+1].coords()[1]

            path_length = sum(l)
            if flag == 2:
                code.append('G00 X{:.2f} Y{:.2f} '.format(x[0], y[0]) + extrusion_symbol + '{:.2f}\n'.format(startExtraLength))
                code.append('Z{:.2f}\n'.format(z - startCompression))
                code.append('G4 S{}\n'.format(startCompressionTime))
                code.append('G92 ' + extrusion_symbol +'0.00\n')
                code.append('Z{:.2f}\n'.format(z))
            code.append('G92 ' + extrusion_symbol +'0.00\n')
            residual_path = path_length
            extrusion = 0.0

            for j in range(len(x)-1):
                if (flag==0 or flag==2):
                    extrusion += l[j]*self.map(x[j+1], y[j+1])
                    code.append('G01 X{:.2f} Y{:.2f} '.format(x[j+1], y[j+1]) + extrusion_symbol + '{:.2f} '.format(extrusion) + 'F{:.2f}\n'.format(self.feed(x[0], y[0])))
                else:
                    code.append('G01 X{:.2f} Y{:.2f} '.format(x[j+1], y[j+1]) + 'F{:.2f}\n'.format(self.feed(x[0], y[0])))
                residual_path -= l[j]
                if residual_path <= self.cutmergin and (flag == 0 or flag == 2):
                    if np.sqrt((x1[0]-x[-1])**2+(y1[0]-y[-1])**2) > 5:
                        code.append(self.cutCommand)
                        flag = 1
                    else:
                        flag = 0
            code.append('G92 ' + extrusion_symbol +'0.00\n')
        return code